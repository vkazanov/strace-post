* TODO Аннотация
* Происхождение видов

  Главный интерфейс между программами и ядром операционной системы в традиционных Unix-подобных
  операционных системах это системные вызовы (англ. system calls, syscalls). Любой программист и
  даже просто продвинутый пользователь таких систем обычно получает документацию, больше похожую на
  справку для программистов, нежели помощь для неспециалистов - знаменитые man-ы.

  В первой публичной (и *пока* еще открытой) версии Unix ([[https://en.wikipedia.org/wiki/Version_6_Unix][Version 6 Unix]], 1975 год) простого способа
  отслеживать системные вызовы программы не было, тем более что ключевые утилиты поставлялись вместе
  с исходным кодом.

  Из отладчиков в системе был древний [[http://doc.cat-v.org/unix/v6/operating-systems-lecture-notes/v6/doc/I/db.html][db]], позволяющий исследовать образ памяти (англ. core dump)
  завершившего работу процесса, и новый [[http://doc.cat-v.org/unix/v6/operating-systems-lecture-notes/v6/doc/I/cdb.html][cdb]], похожий на современные интерактивные отладчики.
  Обеспечил возможность отладчика на лету исследовать и менять память отлаживаемых процессов новый
  системный вызов - [[http://doc.cat-v.org/unix/v6/operating-systems-lecture-notes/v6/doc/II/ptrace.html][ptrace]].

  Ptrace - чрезвычайно (слишком?) мощный инструмент, и в конце 80-х (в эпоху коммерческого уже
  [[https://en.wikipedia.org/wiki/UNIX_System_V#SVR4][System V Release 4]], 1988 года) на этой основе появились специализированные отладчики:
  трассировщики системных вызовов. Самым ранним из них, насколько мне удалось выяснить, стал [[https://en.wikipedia.org/wiki/Truss_(Unix)][truss]].

  Простота в использовании и возможность исследовать поведение программ без доступа к исходному коду
  сделали трассировщики обязательным атрибутом всех коммерческих и свободных Unix-подобных
  операционных систем.

  [[https://stuff.mit.edu/afs/sipb/project/eichin/cruft/machine/sun/sun-Strace][Первая версия]] strace была опубликована Полом Кроненбургом (англ. Paul Kranenburg) в рассылке
  comp.sources.sun в 1992 году в качестве альтернативы закрытой утилите trace от Sun. Как клон, так
  и оригинал предназначались для SunOS, но к 1994 году strace была портирована на System V, Solaris
  и лавинообразно набирающий популярность Linux.

  В наши дни strace работает только на Linux, и вместе с этой операционной системой портирован на
  десятки популярных архитектур. В отличие некоторых других трассировщиков и отладчиков strace
  по-прежнему опирается на системный вызов [[https://linux.die.net/man/2/ptrace][ptrace]], обросший множеством специфичных для Linux
  расширений.

  Текущий (и весьма активный) мейнтейнер strace - [[https://github.com/ldv-alt][Дмитрий Левин]] (англ. Dmitry Levin). При нем
  утилита обросла множеством возможностей, вроде инъекции ошибок в системные вызовы, поддержкой
  широко спектра архитектур и, что самое главное, [[https://en.wikipedia.org/wiki/Strace#/media/File:Strace_logo.svg][маскотом-страусом]]. Неформальные источники
  утверждают, что выбор пал на страуса из-за созвучности русского слова "страус" и английского
  "strace".

  Немаловажно, что системный вызов ptrace и трассировщики так и не было включены в POSIX, несмотря
  на длинную историю и наличие реализации в Linux, FreeBSD, OpenBSD и традиционных Unix.

* Пример: запуск программы под управлением strace

В качестве первого примера использования strace, пожалуй, стоит начать с популярнейшего из способов
использования утилиты: запуска исследуемого приложения непосредственно под управлением strace. А
чтобы копаться в бесконечных листингах мы напишем [[https://github.com/vkazanov/strace-post/blob/master/examples/write-simple.c][минимальную программу]], состояющую буквально из
единственного вызова:

#+BEGIN_SRC c
int main(int argc, char *argv[])
{
    char str[] = "write me to stdout\n";
    /* write(2) is a simple wrapper around a syscall so it should be easy to
     * find in the syscall trace. */
    if (sizeof(str) != write(STDOUT_FILENO, str, sizeof(str))){
        perror("write");
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

#+END_SRC

Соберем программу и убедимся, что она работает:

#+begin_example
$ gcc examples/write-simple.c -o write-simple
$ ./write-simple
write me to stdout
#+end_example

И, наконец, запустим ее под управлением strace:

#+begin_example
$ strace ./write-simple
pexecve("./write", ["./write"], 0x7ffebd6145b0 /* 71 vars */) = 0
brk(NULL)                               = 0x55ff5489e000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=197410, ...}) = 0
mmap(NULL, 197410, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7a2a633000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7a2a631000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7a2a04c000
mprotect(0x7f7a2a233000, 2097152, PROT_NONE) = 0
mmap(0x7f7a2a433000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f7a2a433000
mmap(0x7f7a2a439000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f7a2a439000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f7a2a6324c0) = 0
mprotect(0x7f7a2a433000, 16384, PROT_READ) = 0
mprotect(0x55ff52b52000, 4096, PROT_READ) = 0
mprotect(0x7f7a2a664000, 4096, PROT_READ) = 0
munmap(0x7f7a2a633000, 197410)          = 0
write(1, "write me to stdout\n\0", 20write me to stdout
)  = 20
exit_group(0)                           = ?
#+end_example

Гм, очень многословно и не очень познавательно. Давайте для начала разделим стандартный поток вывода
программы и стандартный вывод ошибок strace при помощи ключа =-o=:

#+begin_example
$ strace -o write-simple.log ./write-simple
write me to stdout
$ cat write-simple.log
execve("./write", ["./write"], 0x7ffee8696810 /* 71 vars */) = 0
brk(NULL)                               = 0x5620a234a000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=197410, ...}) = 0
mmap(NULL, 197410, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f588eee8000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f588eee6000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f588e901000
mprotect(0x7f588eae8000, 2097152, PROT_NONE) = 0
mmap(0x7f588ece8000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f588ece8000
mmap(0x7f588ecee000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f588ecee000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f588eee74c0) = 0
mprotect(0x7f588ece8000, 16384, PROT_READ) = 0
mprotect(0x5620a15c9000, 4096, PROT_READ) = 0
mprotect(0x7f588ef19000, 4096, PROT_READ) = 0
munmap(0x7f588eee8000, 197410)          = 0
write(1, "write me to stdout\n\0", 20)  = 20
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

Теперь весь вывод пишется в отдельный файл, а стандартные потоки исследуемой программы не
перемешиваются с описаниями системных вызовов. Впрочем, в исследовании интересных вызовов нам это
все равно не помогает - даже примитивная программа делает их слишком много. Предположим, что нас
интересуют только вызовы write:

#+begin_example
$ strace -e trace=write -owrite-simple.log ./write-simple
write me to stdout
$ cat write-simple.log
write(1, "write me to stdout\n\0", 20
)  = 20
+++ exited with 0 +++
#+end_example

Ключ =-e= позволяет указывать выражения, по которым будут фильтроваться системные вызовы. Самый
популярный вариант условия, естественно, это =trace=*=, при помощи которого можно оставлять интересные
системные вызовы или, наоборот, исключать неинтересные.

Давай уберем системные вызовы, связанные с выделением и высвобождением памяти:

#+begin_example
$ strace -e trace=\!brk,mmap,mprotect,munmap -owrite-simple.log ./write-simple
write me to stdout
$ cat write-simple.log
execve("./write-simple", ["./write-simple"], 0x7ffe9972a498 /* 69 vars */) = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=124066, ...}) = 0
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f00f0be74c0) = 0
write(1, "write me to stdout\n\0", 20)  = 20
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

Обратите внимание на экранированный восклицательный знак в списке исключенных вызовов: этого требует
командная оболочка (англ. shell).

Обратите внимание, что в моей версии glibc завершает исполнение процесса системный вызов =exit_group=
, а не более традиционный =_exit= . Это еще одна проблема работы на уровне strace: интерфейс, с
которым работает программист не имеет прямого отношения к системным вызовам. Более того, интерфейс
тот регулярно меняется в зависимости от реализации и платформы.

* Пример: присоединение к работающему процессу

Изначально системный вызов ptrace, на котором построены все возможности strace, требовал
специального запуска программы. Такое ограничение, быть может, звучало разумно во времени Version 6
Unix, в наших дни этого уже недостаточного: бывает необходимо исследовать проблемы прямо на
работающей программе. Типичный пример - заблокированный на дескрипторе или спящий процесс. Поэтому
современные strace и отладчики научились просоединяться к процессам на лету.

Давайте посмотрим на пример "зависнувшей" [[https://github.com/vkazanov/strace-post/blob/master/examples/write-sleep.c][программы]]:

#+BEGIN_SRC c
int main(int argc, char *argv[])
{
    (void) argc; (void) argv;

    char str[] = "write me\n";

    write(STDOUT_FILENO, str, sizeof(str));

    /* Sleep indefinitely or until a signal arrives */
    pause();

    write(STDOUT_FILENO, str, sizeof(str));

    return EXIT_SUCCESS;
}
#+END_SRC

Соберем программу и убедимся, что она "зависла":

#+begin_example
$ gcc examples/write-sleep.c -o write-sleep
$ ./write-sleep
./write-sleep
write me
^C
$
#+end_example

А теперь попробуем присоединиться к ней:

#+begin_example
$ ./write-sleep &
[1] 15329
write me
$ strace -p 15329
strace: Process 15329 attached
pause(
^Cstrace: Process 15329 detached
 <detached ...>
#+end_example

Программа заблокирована вызовом pause. Проверим, как программа отреагирует на сигнал:

#+begin_example
$ strace -o write-sleep.log -p 15329 &
strace: Process 15329 attached
$
$ kill -CONT 15329
$ cat write-sleep.log
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
--- SIGCONT {si_signo=SIGCONT, si_code=SI_USER, si_pid=14989, si_uid=1001} ---
pause(
$
$ kill -TERM 15329
$ cat write-sleep.log
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
--- SIGCONT {si_signo=SIGCONT, si_code=SI_USER, si_pid=14989, si_uid=1001} ---
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=14989, si_uid=1001} ---
+++ killed by SIGTERM +++
#+end_example

Итак, мы запустили "зависнувшую" программу и присоединились к ней при помощи strace. Выяснились две
вещи: системный вызов pause игнорирует сигналы без обработчиков и, что интересней, strace позволяет
отслеживать не только системные вызовы, но и входящие сигналы.

* Пример: отслеживание дочерних процессов

Работа с процессами через вызов fork - основа всех UNIX. Дайте посмотрим, как strace работает с
деревом процессом на примере несложной "плодящейся" [[https://github.com/vkazanov/strace-post/blob/master/examples/fork-write.c][программы]]:

#+BEGIN_SRC c
int main(int argc, char *argv[])
{
    pid_t parent_pid = getpid();
    pid_t child_pid = fork();
    if (child_pid == 0) {
        /* A child is born! */
        child_pid = getpid();

        /* In the end of the day printf is just a call to write(2). */
        printf("child (self=%d)\n", child_pid);
        exit(EXIT_SUCCESS);
    }

    printf("parent (self=%d, child=%d)\n", parent_pid, child_pid);

    wait(NULL);

    exit(EXIT_SUCCESS);
}
#+END_SRC

Здесь исходный процесс создает дочерний процесс, оба пишут в стандартный поток вывода:

#+begin_example
$ gcc examples/fork-write.c -o fork-write
$ ./fork-write
parent (self=11274, child=11275)
child (self=11275)
#+end_example

По умолчанию мы увидим только те системные вызовы родителького процесса:

#+begin_example
$ strace -e trace=write -ofork-write.log ./fork-write
child (self=22049)
parent (self=22048, child=22049)
$ cat fork-write.log
write(1, "parent (self=22048, child=22049)"..., 33) = 33
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=22049, si_uid=1001, si_status=0, si_utime=0, si_stime=0} ---
+++ exited with 0 +++
#+end_example

Отслеживать все дерево процессов помогает флаг =-f=, с которым strace отслеживает системные вызовы в
процессов-потомков. К каждой строке вывода при этом добавляется =pid= процесса, делающего системный
вывод:

#+begin_example
$ strace -f -e trace=write -ofork-write.log ./fork-write
parent (self=22710, child=22711)
child (self=22711)
$ cat fork-write.log
22710 write(1, "parent (self=22710, child=22711)"..., 33) = 33
22711 write(1, "child (self=22711)\n", 19) = 19
22711 +++ exited with 0 +++
22710 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=22711, si_uid=1001, si_status=0, si_utime=0, si_stime=0} ---
22710 +++ exited with 0 +++

#+end_example

В этом контексте может пригодиться фильтрация групп системных вызовов:

#+begin_example
$ strace -f -e trace=%process -ofork-write.log ./fork-write
parent (self=23610, child=23611)
child (self=23611)
$ cat fork-write.log
23610 execve("./fork-write", ["./fork-write"], 0x7fff696ff720 /* 63 vars */) = 0
23610 arch_prctl(ARCH_SET_FS, 0x7f3d03ba44c0) = 0
23610 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f3d03ba4790) = 23611
23610 wait4(-1,  <unfinished ...>
23611 exit_group(0)                     = ?
23611 +++ exited with 0 +++
23610 <... wait4 resumed> NULL, 0, NULL) = 23611
23610 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=23611, si_uid=1001, si_status=0, si_utime=0, si_stime=0} ---
23610 exit_group(0)                     = ?
23610 +++ exited with 0 +++

#+end_example

Кстати, какой системный вызов используется для создания нового процесса?

* Пример: пути к файлами вместо дескрипторов

Знать конкретные файловые дескрипторы, безусловно, может быть полезно, но имена конкретных файлов, к
которым обращается программа, тоже могут пригодиться.

Следующая [[https://github.com/vkazanov/strace-post/blob/master/examples/write-tmp-file.c][программа]] пишет строку во временный файл:

#+begin_src c
void do_write(int out_fd)
{
    char str[] = "write me to a file\n";

    if (sizeof(str) != write(out_fd, str, sizeof(str))){
        perror("write");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    char tmp_filename_template[] = "/tmp/output_fileXXXXXX";

    int out_fd = mkstemp(tmp_filename_template);
    if (out_fd == -1) {
        perror("mkstemp");
        exit(EXIT_FAILURE);
    }

    do_write(out_fd);

    return EXIT_SUCCESS;
}
#+end_src

При обычном вызове strace покажет значение числа-дескриптора, переданного в системный вызов:

#+begin_example
$ strace -e trace=write -o write-tmp-file.log ./write-tmp-file
$ cat write-tmp-file.log
write(3, "write me to a file\n\0", 20)  = 20
+++ exited with 0 +++
#+end_example

С флагом =-y= утилита показывает путь к файлу, на который указывает дескриптов:

#+begin_example
$ strace -y -e trace=write -o write-tmp-file.log ./write-tmp-file
$ cat write-tmp-file.log
write(3</tmp/output_fileCf5MyW>, "write me to a file\n\0", 20) = 20
+++ exited with 0 +++
#+end_example

* Пример: отслеживание обращений к конкретным файлам

Еще одна полезная возможность: отображать только системные вызовы, связанные только с конкретным
файлом. Следующая [[https://github.com/vkazanov/strace-post/blob/master/examples/write-file.c][программа]] дописывает строку в произвольный файл, переданный в аргументе:

#+begin_src c
void do_write(int out_fd)
{
    char str[] = "write me to a file\n";

    if (sizeof(str) != write(out_fd, str, sizeof(str))){
        perror("write");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    /*
     * Path will be provided by the first program argument.
     *  */
    const char *path = argv[1];

    /*
     * Open an existing file for writing in append mode.
     *  */
    int out_fd = open(path, O_APPEND | O_WRONLY);
    if (out_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    do_write(out_fd);

    return EXIT_SUCCESS;
}

#+end_src

По умолчанию strace выводит много лишней информации:

#+begin_example
$ strace -y -o write-file.log ./write-file /tmp/test_file.log
open: No such file or directory
$ touch /tmp/test_file.log
$ strace -y -o write-file.log ./write-file /tmp/test_file.log
$ cat write-file.log
execve("./write-file", ["./write-file", "/tmp/test_file.log"], 0x7fff3df2b660 /* 64 vars */) = 0
brk(NULL)                               = 0x563127f35000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3</etc/ld.so.cache>
fstat(3</etc/ld.so.cache>, {st_mode=S_IFREG|0644, st_size=124066, ...}) = 0
mmap(NULL, 124066, PROT_READ, MAP_PRIVATE, 3</etc/ld.so.cache>, 0) = 0x7f1e7145e000
close(3</etc/ld.so.cache>)              = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3</lib/x86_64-linux-gnu/libc-2.27.so>
read(3</lib/x86_64-linux-gnu/libc-2.27.so>, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3</lib/x86_64-linux-gnu/libc-2.27.so>, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1e7145c000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3</lib/x86_64-linux-gnu/libc-2.27.so>, 0) = 0x7f1e70e65000
mprotect(0x7f1e7104c000, 2097152, PROT_NONE) = 0
mmap(0x7f1e7124c000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3</lib/x86_64-linux-gnu/libc-2.27.so>, 0x1e7000) = 0x7f1e7124c000
mmap(0x7f1e71252000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f1e71252000
close(3</lib/x86_64-linux-gnu/libc-2.27.so>) = 0
arch_prctl(ARCH_SET_FS, 0x7f1e7145d4c0) = 0
mprotect(0x7f1e7124c000, 16384, PROT_READ) = 0
mprotect(0x56312604f000, 4096, PROT_READ) = 0
mprotect(0x7f1e7147d000, 4096, PROT_READ) = 0
munmap(0x7f1e7145e000, 124066)          = 0
openat(AT_FDCWD, "/tmp/test_file.log", O_WRONLY|O_APPEND) = 3</tmp/test_file.log>
write(3</tmp/test_file.log>, "write me to a file\n\0", 20) = 20
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

Флаг =-P= с аргументом заставляет strace выводить только обращения к указанному файлу:

#+begin_example
$ strace -y -P/tmp/test_file.log -o write-file.log ./write-file /tmp/test_file.log
$ cat write-file.log
openat(AT_FDCWD, "/tmp/test_file.log", O_WRONLY|O_APPEND) = 3</tmp/test_file.log>
write(3</tmp/test_file.log>, "write me to a file\n\0", 20) = 20
+++ exited with 0 +++
#+end_example

* Пример: многопоточные программы

Strace может помочь и при работе с многопоточной [[https://github.com/vkazanov/strace-post/blob/master/examples/thread-write.c][программой]]. Следующая программа пишет в стандартный
поток вывода из двух потоков:

#+begin_src c
void *thread(void *arg)
{
    (void) arg;

    printf("Secondary thread: working\n");
    sleep(1);
    printf("Secondary thread: done\n");

    return NULL;
}

int main(int argc, char *argv[])
{
    printf("Initial thread: launching a thread\n");

    pthread_t thr;
    if (0 != pthread_create(&thr, NULL, thread, NULL)) {
        fprintf(stderr, "Initial thread: failed to create a thread");
        exit(EXIT_FAILURE);
    }

    printf("Initial thread: joining a thread\n");
    if (0 != pthread_join(thr, NULL)) {
        fprintf(stderr, "Initial thread: failed to join a thread");
        exit(EXIT_FAILURE);
    };

    printf("Initial thread: done");

    exit(EXIT_SUCCESS);
}
#+end_src

Собирать ее надо, естественно, со специальным приветом линковщика - флагом =-pthread=:

#+begin_example
$ gcc examples/thread-write.c -pthread -o thread-write
$ ./thread-write
/thread-write
Initial thread: launching a thread
Initial thread: joining a thread
Secondary thread: working
Secondary thread: done
Initial thread: done
$
#+end_example

Флаг =-f=, как и в случае с обычными процессами, добавит в начало каждой строки pid процесса.

#+begin_quote
Естественно, что речь идет не об идентификаторе потока в смысле реализации стандарта POSIX threads,
а просто номер, используемый планировщиком задач Linux. С точки зрения последнего нет никаких
процессов или потоков, но есть задачи, которые надо распределить по доступным ядрам машины.
#+end_quote

При работе в несколько потоков системных вызовов становится слишком много:

#+begin_example
$ strace -f -othread-write.log ./thread-write
$ wc -l thread-write.log
60 thread-write.log
#+end_example

Имеет смысл ограничиться только управлением процессами и системным вызовом write:

#+begin_example
$ strace -f -e trace="%process,write" -othread-write.log ./thread-write
$ cat thread-write.log
18211 execve("./thread-write", ["./thread-write"], 0x7ffc6b8d58f0 /* 64 vars */) = 0
18211 arch_prctl(ARCH_SET_FS, 0x7f38ea3b7740) = 0
18211 write(1, "Initial thread: launching a thre"..., 35) = 35
18211 clone(child_stack=0x7f38e9ba2fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7f38e9ba39d0, tls=0x7f38e9ba3700, child_tidptr=0x7f38e9ba39d0) = 18212
18211 write(1, "Initial thread: joining a thread"..., 33) = 33
18212 write(1, "Secondary thread: working\n", 26) = 26
18212 write(1, "Secondary thread: done\n", 23) = 23
18212 exit(0)                           = ?
18212 +++ exited with 0 +++
18211 write(1, "Initial thread: done", 20) = 20
18211 exit_group(0)                     = ?
18211 +++ exited with 0 +++

#+end_example

Какой системный вызов используется для создания нового процесса? Чем такой вызов для потоков
отличается от вызова для процессов?

* Пример: стек процесса в момент системного вызова

Одна из недавно появившихся в strace возможностей - отображение стека вызовов функций в момент
системного вызова. Простой [[https://github.com/vkazanov/strace-post/blob/master/examples/write-simple.c][пример]]:

#+begin_src c
void do_write(void)
{
    char str[] = "write me to stdout\n";
    if (sizeof(str) != write(STDOUT_FILENO, str, sizeof(str))){
        perror("write");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    do_write();
    return EXIT_SUCCESS;
}
#+end_src

Естественно, что вывод программы при этом становится очень многословным и помимо, собственно, флага
=-k= (отображение стека вызовов) имеет смысл сразу фильтровать по имени системного вызова:

#+begin_example
$ gcc examples/write-simple.c -o write-simple
$ strace -k -e trace=write -o write-simple.log ./write-simple
write me to stdout
$ cat write-simple.log
write(1, "write me to stdout\n\0", 20)  = 20
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /home/vkazanov/projects-my/strace-post/write-simple(do_write+0x50) [0x78a]
 > /home/vkazanov/projects-my/strace-post/write-simple(main+0x14) [0x7d1]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/vkazanov/projects-my/strace-post/write-simple(_start+0x2a) [0x65a]
+++ exited with 0 +++
#+end_example

* Пример: инъекция ошибок

И еще одна новая иочень полезная возможность: инъекция ошибок. Вот [[https://github.com/vkazanov/strace-post/blob/master/examples/write-twice.c][программа]], пишущая две строки в
поток вывода:

#+begin_src c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void do_write(const char *str, ssize_t len)
{
    if (len != write(STDOUT_FILENO, str, (size_t)len)){
        perror("write");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    (void) argc; (void) argv;

    char str1[] = "write me 1\n";
    do_write(str1, sizeof(str1));

    char str2[] = "write me 2\n";
    do_write(str2, sizeof(str2));

    return EXIT_SUCCESS;
}
#+end_src

Отслеживаем оба вызова write:

#+begin_example
$ gcc examples/write-twice.c -o write-twice
$ ./write-twice
write me 1
write me 2
$ strace -e trace=write -owrite-twice.log ./write-twice
write me 1
write me 2
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = 12
write(1, "write me 2\n\0", 12)          = 12
+++ exited with 0 +++
#+end_example

А теперь используем выражение inject, чтобы вставить ошибку EBADF во все вызовы write:

#+begin_example
$ strace -e trace=write -e inject=write:error=EBADF -owrite-twice.log ./write-twice
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = -1 EBADF (Bad file descriptor) (INJECTED)
write(3, "write: Bad file descriptor\n", 27) = -1 EBADF (Bad file descriptor) (INJECTED)
+++ exited with 1 +++
#+end_example

Интересно, что ошибки возвращают *все* вызовы write, включая вызов, скрытый за perror. Имеет смысл
возвращать ошибку только для первого из вызовов:

#+begin_example
$ strace -e trace=write -e inject=write:error=EBADF:when=1 -owrite-twice.log ./write-twice
write: Bad file descriptor
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = -1 EBADF (Bad file descriptor) (INJECTED)
write(3, "write: Bad file descriptor\n", 27) = 27
+++ exited with 1 +++
#+end_example

Или второго:

#+begin_example
$ strace -e trace=write -e inject=write:error=EBADF:when=2 -owrite-twice.log ./write-twice
write me 1
write: Bad file descriptor
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = 12
write(1, "write me 2\n\0", 12)          = -1 EBADF (Bad file descriptor) (INJECTED)
write(3, "write: Bad file descriptor\n", 27) = 27
+++ exited with 1 +++
#+end_example

Вид ошибки указывать не обязательно:

#+begin_example
$ strace -e trace=write -e fault=write:when=1 -owrite-twice.log ./write-twice
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = -1 ENOSYS (Function not implemented) (INJECTED)
write(3, "write: Function not implemented\n", 32) = 32
+++ exited with 1 +++
#+end_example

В сочетании с другими флагами можно "ломать" обращения к конкретному файлу. Пример:

#+begin_example
$ strace -y -P/tmp/test_file.log -e inject=file:error=ENOENT -o write-file.log ./write-file /tmp/test_file.log
open: No such file or directory
$ cat write-file.log
openat(AT_FDCWD, "/tmp/test_file.log", O_WRONLY|O_APPEND) = -1 ENOENT (No such file or directory) (INJECTED)
+++ exited with 1 +++
#+end_example

Помимо, собственно, инъекции ошибок [[http://www.man7.org/linux/man-pages/man1/strace.1.html][можно]] имитировать задержки при выполнение вызовов, получение
сигналов и контролировать поведение системных выводов.
* Устройство strace в двух словах: Piglet Trace

Одна из мои любимых особенностей исходной культуры UNIX и современного Linux - традиция открытого
исходного кода. Возможность ознакомления с кодом приложений и даже ядра операционной системы
позволяет лучше понять принципы работы любимых инструментов, не полагаясь на вечно устаревающую
техническую документацию.

Конечно, в рамках данной статьи разбирать исходный код самого strace не разумно, вместо этого я
приведу код миниатюрный клон трассировщика - [[https://github.com/vkazanov/strace-post/blob/master/examples/piglet-trace.c][Piglet Trace]] (ptr).

Использовать трассировщик просто:

#+begin_example
$ gcc examples/piglet-trace.c -o ptr
$ ptr echo test > /dev/null
BRK(12) -> 94744690540544
ACCESS(21) -> 18446744073709551614
ACCESS(21) -> 18446744073709551614
unknown(257) -> 3
FSTAT(5) -> 0
MMAP(9) -> 140694657216512
CLOSE(3) -> 0
ACCESS(21) -> 18446744073709551614
unknown(257) -> 3
READ(0) -> 832
FSTAT(5) -> 0
MMAP(9) -> 140694657208320
MMAP(9) -> 140694650953728
MPROTECT(10) -> 0
MMAP(9) -> 140694655045632
MMAP(9) -> 140694655070208
CLOSE(3) -> 0
unknown(158) -> 0
MPROTECT(10) -> 0
MPROTECT(10) -> 0
MPROTECT(10) -> 0
MUNMAP(11) -> 0
BRK(12) -> 94744690540544
BRK(12) -> 94744690675712
unknown(257) -> 3
FSTAT(5) -> 0
MMAP(9) -> 140694646390784
CLOSE(3) -> 0
FSTAT(5) -> 0
IOCTL(16) -> 18446744073709551591
WRITE(1) -> 5
CLOSE(3) -> 0
CLOSE(3) -> 0
unknown(231)
Tracee terminated
#+end_example

Piglet Trace понимает порядка сотни системных вызовов (см. приложенную [[https://github.com/vkazanov/strace-post/blob/master/examples/piglet-trace-syscalls.h][таблицу]]) Linux и работает
только на архитектуре x86-64, чего для учебных целей вполне хватает.

Давайте разберем работу нашего клона. Под Linux для отладчиков и трассировщиков используется, как
упоминалось выше, системный вызов ptrace. Последний работает посредством передачи в первом аргументе
идентификаторов выполняемых над исследуемым процессом команд, из которых нам потребуются только
PTRACE_TRACEME, PTRACE_SYSCALL и PTRACE_GETREGS.

Работа трассировщика начинается в традиционном UNIX-стиле: fork(2) запускает дочерний процесс;
последний с помощью exec(3) запускает исследуемую программу. Единственная тонкость здесь - вызов
ptrace(PTRACE_TRACEME) перед exec. Процесс-потомок, таким образом, ожидает, что процесс-родитель
будет его отслеживать:

#+begin_src c
pid_t child_pid = fork();
switch (child_pid) {
case -1:
    err(EXIT_FAILURE, "fork");
case 0:
    /* Child here */
    /* A traced mode has to be enabled. A parent will have to wait(2) for it
     * to happen. */
    ptrace(PTRACE_TRACEME, 0, NULL, NULL);
    /* Replace itself with a program to be run. */
    execvp(argv[1], argv + 1);
    err(EXIT_FAILURE, "exec");
}
#+end_src

Процесс-родитель теперь должен вызвать wait(2) на дочернем процесс, то есть убедиться, что
переключение в режим трассировки произошло:

#+begin_src c
/* Parent */

/* First we wait for the child to set the traced mode (see
 * ptrace(PTRACE_TRACEME) above) */
if (waitpid(child_pid, NULL, 0) == -1)
    err(EXIT_FAILURE, "traceme -> waitpid");
#+end_src

На этом приготовления закончены и можно приступать, собственно, к отслеживанию системных вызовов в
бесконечном цикле.

Вызов ptrace(PTRACE_SYSCALL) гарантирует, что последующий wait родителя завершится либо перед
исполнением системного вызова, либо сразу после его завершения. Между двумя вызовами можно провести
какие-либо действия: подменить вызов на альтернативный, изменить аргументы или возвращаемое
значение.

Нам же достаточно дважды вызвать команду ptrace(PTRACE_GETREGS), чтобы получить состояние регистра
rax до вызова (номер системного вызова) и сразу после (возвращаемое значение).

Собственно, цикл:

#+begin_src c
/* A system call tracing loop, one interation per call. */
for (;;) {
    /* A non-portable structure defined for ptrace/GDB/strace usage mostly.
     * It allows to conveniently dump and access register state using
     * ptrace. */
    struct user_regs_struct registers;

    /* Enter syscall: continue execution until the next system call
     * beginning. Stop right before syscall.
     *
     * It's possible to change the system call number, system call
     * arguments, return value or even avoid executing the system call
     * completely. */
    if (ptrace(PTRACE_SYSCALL, child_pid, NULL, NULL) == -1)
        err(EXIT_FAILURE, "enter_syscall");
    if (waitpid(child_pid, NULL, 0) == -1)
        err(EXIT_FAILURE, "enter_syscall -> waitpid");

    /* According to the x86-64 system call convention on Linux (see man 2
     * syscall) the number identifying a syscall should be put into the rax
     * general purpose register, with the rest of the arguments residing in
     * other general purpose registers (rdi,rsi, rdx, r10, r8, r9). */
    if (ptrace(PTRACE_GETREGS, child_pid, NULL, &registers) == -1)
        err(EXIT_FAILURE, "enter_syscall -> getregs");

    /* Note how orig_rax is used here. That's because on x86-64 rax is used
     * both for executing a syscall, and returning a value from it. To
     * differentiate between the cases both rax and orig_rax are updated on
     * syscall entry/exit, and only rax is updated on exit. */
    print_syscall_enter(registers.orig_rax);

    /* Exit syscall: execute of the syscall, and stop on system
     * call exit.
     *
     * More system call tinkering possible: change the return value, record
     * time it took to finish the system call, etc. */
    if (ptrace(PTRACE_SYSCALL, child_pid, NULL, NULL) == -1)
        err(EXIT_FAILURE, "exit_syscall");
    if (waitpid(child_pid, NULL, 0) == -1)
        err(EXIT_FAILURE, "exit_syscall -> waitpid");

    /* Retrieve register state again as we want to inspect system call
     * return value. */
    if (ptrace(PTRACE_GETREGS, child_pid, NULL, &registers) == -1) {
        /* ESRCH is returned when a child terminates using a syscall and no
         * return value is possible, e.g. as a result of exit(2). */
        if (errno == ESRCH) {
            fprintf(stderr, "\nTracee terminated\n");
            break;
        }
        err(EXIT_FAILURE, "exit_syscall -> getregs");
    }

    /* Done with this system call, let the next iteration handle the next
     * one */
    print_syscall_exit(registers.rax);
}
#+end_src

Ну, вот и весь трассировщик. Теперь вы знаете, с чего начинать портирование [[https://en.wikipedia.org/wiki/DTrace][DTrace]] под Linux.
