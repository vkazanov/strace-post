* TODO Аннотация
* Происхождение видов

  Главный интерфейс между программами и ядром операционной системы в традиционных Unix-подобных
  операционных системах это системные вызовы (англ. system calls, syscalls). Любой программист и
  даже просто продвинутый пользователь таких систем обычно получает документацию, больше похожую на
  справку для программистов, нежели помощь для неспециалистов - знаменитые man-ы.

  В первой публичной (и *пока* еще открытой) версии Unix ([[https://en.wikipedia.org/wiki/Version_6_Unix][Version 6 Unix]], 1975 год) простого способа
  отслеживать системные вызовы программы не было, тем более что ключевые утилиты поставлялись вместе
  с исходным кодом.

  Из отладчиков в системе был древний [[http://doc.cat-v.org/unix/v6/operating-systems-lecture-notes/v6/doc/I/db.html][db]], позволяющий исследовать образ памяти (англ. core dump)
  завершившего работу процесса, и новый [[http://doc.cat-v.org/unix/v6/operating-systems-lecture-notes/v6/doc/I/cdb.html][cdb]], похожий на современные интерактивные отладчики.
  Обеспечил возможность отладчика на лету исследовать и менять память отлаживаемых процессов новый
  системный вызов - [[http://doc.cat-v.org/unix/v6/operating-systems-lecture-notes/v6/doc/II/ptrace.html][ptrace]].

  Ptrace - чрезвычайно (слишком?) мощный инструмент, и в конце 80-х (в эпоху коммерческого уже
  [[https://en.wikipedia.org/wiki/UNIX_System_V#SVR4][System V Release 4]], 1988 года) на этой основе появились специализированные отладчики:
  трассировщики системных вызовов. Самым ранним из них, насколько мне удалось выяснить, стал [[https://en.wikipedia.org/wiki/Truss_(Unix)][truss]].

  Простота в использовании по сравнению и возможности исследовать поведение программ без доступа к
  исходному коду сделали трассировщики обязательным атрибутом всех коммерческих и свободных
  Unix-подобных операционных систем.

  [[https://stuff.mit.edu/afs/sipb/project/eichin/cruft/machine/sun/sun-Strace][Первая версия]] strace была опубликована Полом Кроненбургом (англ. Paul Kranenburg) в рассылке
  comp.sources.sun в 1992 году в качестве альтернативы закрытой утилите trace от Sun. Как клон, так
  и оригинал предназначались для SunOS, но к 1994 году strace была портирована на System V, Solaris
  и лавинообразно набирающий популярность Linux.

  В наши дни strace работает только на Linux, и вместе с этой операционной системой портирован на
  десятки популярных архитектур. В отличие некоторых других трассировщиков и отладчиков strace
  по-прежнему опирается на системный вызов [[https://linux.die.net/man/2/ptrace][ptrace]], обросший множеством специфичных для Linux
  расширений.

  Текущий - и весьма активный - мейнтейнер strace - [[https://github.com/ldv-alt][Дмитрий Левин]] (англ. Dmitry Levin). При нем
  утилита обросла множеством возможностей, вроде инъекции ошибок в системные вызовы, поддержкой
  широко спектра архитектур и, что самое главное, [[https://en.wikipedia.org/wiki/Strace#/media/File:Strace_logo.svg][маскотом-страусом]]. Неформальные источники
  утверждают, что страуса было решено использовать из-за созвучности русского слова "страус" и
  английского "strace".

  Немаловажно, что системный вызов ptrace и трассировщики так и не было включены в POSIX, несмотря
  на длинную историю и наличие реализации в Linux, FreeBSD, OpenBSD и традиционных Unix.


* Пример: запуск программы под управлением strace

В качестве первого примера использования strace, пожалуй, стоит начать с популярнейшего из способов
использования утилиты: запуска исследуемого приложения непосредственно под управлением strace. А
чтобы копаться в бесконечных листингах мы напишем [[https://github.com/vkazanov/strace-post/blob/master/examples/write-simple.c][минимальную программу]], состояющую буквально из
единственного вызова:

#+BEGIN_SRC c
int main(int argc, char *argv[])
{
    char str[] = "write me to stdout\n";
    /* write(2) is a simple wrapper around a syscall so it should be easy to
     * find in the syscall trace. */
    if (sizeof(str) != write(STDOUT_FILENO, str, sizeof(str))){
        perror("write");
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

#+END_SRC

Соберем программу и убедимся, что она работает:

#+begin_example
$ gcc examples/write-simple.c -o write-simple
$ ./write-simple
write me to stdout
#+end_example

И, наконец, запустим ее под управлением strace:

#+begin_example
$ strace ./write-simple
pexecve("./write", ["./write"], 0x7ffebd6145b0 /* 71 vars */) = 0
brk(NULL)                               = 0x55ff5489e000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=197410, ...}) = 0
mmap(NULL, 197410, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f7a2a633000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7a2a631000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f7a2a04c000
mprotect(0x7f7a2a233000, 2097152, PROT_NONE) = 0
mmap(0x7f7a2a433000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f7a2a433000
mmap(0x7f7a2a439000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f7a2a439000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f7a2a6324c0) = 0
mprotect(0x7f7a2a433000, 16384, PROT_READ) = 0
mprotect(0x55ff52b52000, 4096, PROT_READ) = 0
mprotect(0x7f7a2a664000, 4096, PROT_READ) = 0
munmap(0x7f7a2a633000, 197410)          = 0
write(1, "write me to stdout\n\0", 20write me to stdout
)  = 20
exit_group(0)                           = ?
#+end_example

Гм, очень многословно и не очень познавательно. Давайте для начала разделим стандартный поток вывода
программы и стандартный вывод ошибок strace при помощи ключа =-o=:

#+begin_example
$ strace -o write-simple.log ./write-simple
write me to stdout
$ cat write-simple.log
execve("./write", ["./write"], 0x7ffee8696810 /* 71 vars */) = 0
brk(NULL)                               = 0x5620a234a000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=197410, ...}) = 0
mmap(NULL, 197410, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f588eee8000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f588eee6000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f588e901000
mprotect(0x7f588eae8000, 2097152, PROT_NONE) = 0
mmap(0x7f588ece8000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f588ece8000
mmap(0x7f588ecee000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f588ecee000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f588eee74c0) = 0
mprotect(0x7f588ece8000, 16384, PROT_READ) = 0
mprotect(0x5620a15c9000, 4096, PROT_READ) = 0
mprotect(0x7f588ef19000, 4096, PROT_READ) = 0
munmap(0x7f588eee8000, 197410)          = 0
write(1, "write me to stdout\n\0", 20)  = 20
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

Теперь весь вывод пишется в отдельный файл, а стандартные потоки исследуемой программы не
перемешиваются с описаниями системных вызовов. Впрочем, в исследовании интересных вызовов нам это
все равно не помогает - даже примитивная программа делает их слишком много. Предположим, что нас
интересуют только вызовы write:

#+begin_example
$ strace -e trace=write -owrite-simple.log ./write-simple
write me to stdout
$ cat write-simple.log
write(1, "write me to stdout\n\0", 20
)  = 20
+++ exited with 0 +++
#+end_example

Ключ =-e= позволяет указывать выражения, по которым будут фильтроваться системные вызовы. Самый
популярный вариант условия, естественно, это =trace=*=, при помощи которого можно оставлять интересные
системные вызовы или, наоборот, исключать неинтересные.

Давай уберем системные вызовы, связанные с выделением и высвобождением памяти:

#+begin_example
$ strace -e trace=\!brk,mmap,mprotect,munmap -owrite-simple.log ./write-simple
write me to stdout
$ cat write-simple.log
execve("./write-simple", ["./write-simple"], 0x7ffe9972a498 /* 69 vars */) = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=124066, ...}) = 0
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f00f0be74c0) = 0
write(1, "write me to stdout\n\0", 20)  = 20
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

Обратите внимание на экранированный восклицательный знак в списке исключенных вызовов: этого требует
командная оболочка (англ. shell).

Обратите внимание, что в моей версии glibc завершает исполнение процесса системный вызов =exit_group=
, а не более традиционный =_exit= . Это еще одна проблема работы на уровне strace: интерфейс, с
которым работает программист не имеет прямого отношения к системным вызовам. Более того, интерфейс
тот регулярно меняется в зависимости от реализации и платформы.

* Пример: присоединение к работающему процессу

Изначально системный вызов ptrace, на котором построены все возможности strace, требовал
специального запуска программы. Такое ограничение, быть может, звучало разумно во времени Version 6
Unix, в наших дни этого уже недостаточного: бывает необходимо исследовать проблемы прямо на
работающей программе. Типичный пример - заблокированный на дескрипторе или спящий процесс. Поэтому
современные strace и отладчики научились просоединяться к процессам на лету.

Давайте посмотрим на пример "зависнувшей" программы:

#+BEGIN_SRC c
int main(int argc, char *argv[])
{
    (void) argc; (void) argv;

    char str[] = "write me\n";

    write(STDOUT_FILENO, str, sizeof(str));

    /* Sleep indefinitely or until a signal arrives */
    pause();

    write(STDOUT_FILENO, str, sizeof(str));

    return EXIT_SUCCESS;
}
#+END_SRC

Соберем программу и убедимся, что она "зависла":

#+begin_example
$ gcc examples/write-sleep.c -o write-sleep
$ ./write-sleep
./write-sleep
write me
^C
$
#+end_example

А теперь попробуем присоединиться к ней:

#+begin_example
$ ./write-sleep &
[1] 15329
write me
$ strace -p 15329
strace: Process 15329 attached
pause(
^Cstrace: Process 15329 detached
 <detached ...>
$
$ strace -o write-sleep.log -p 15329 &
strace: Process 15329 attached
$
$ kill -CONT 15329
$ cat write-sleep.log
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
--- SIGCONT {si_signo=SIGCONT, si_code=SI_USER, si_pid=14989, si_uid=1001} ---
pause(
$
$ kill -TERM 15329
$ cat write-sleep.log
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
--- SIGCONT {si_signo=SIGCONT, si_code=SI_USER, si_pid=14989, si_uid=1001} ---
pause()                                 = ? ERESTARTNOHAND (To be restarted if no handler)
--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=14989, si_uid=1001} ---
+++ killed by SIGTERM +++
#+end_example

Итак, мы запустили "зависающую" программу и присоединились к ней при помощи strace. Выяснились две
вещи: системный вызов pause игнорирует сигналы без обработчиков и, что интересней, strace позволяет
отслеживать не только системные вызовы, но и входящие сигналы.

* TODO Пример: отслеживание дочерних процессов

#+BEGIN_SRC c
int main(int argc, char *argv[])
{
    pid_t parent_pid = getpid();
    pid_t child_pid = fork();
    if (child_pid == 0) {
        /* A child is born! */
        child_pid = getpid();

        /* In the end of the day printf is just a call to write(2). */
        printf("child (self=%d)\n", child_pid);
        exit(EXIT_SUCCESS);
    }

    printf("parent (self=%d, child=%d)\n", parent_pid, child_pid);

    wait(NULL);

    exit(EXIT_SUCCESS);
}
#+END_SRC

#+begin_example
$ gcc examples/fork-write.c -o fork-write
$ ./fork-write
parent (self=11274, child=11275)
child (self=11275)
$ strace -o fork-write.log ./fork-write
parent (self=12084, child=12085)
child (self=12085)
$ cat fork-write.log
execve("./fork-write", ["./fork-write"], 0x7ffc424cef40 /* 71 vars */) = 0
brk(NULL)                               = 0x55e9d8a83000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=197410, ...}) = 0
mmap(NULL, 197410, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f251dba1000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f251db9f000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f251d5ba000
mprotect(0x7f251d7a1000, 2097152, PROT_NONE) = 0
mmap(0x7f251d9a1000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f251d9a1000
mmap(0x7f251d9a7000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f251d9a7000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f251dba04c0) = 0
mprotect(0x7f251d9a1000, 16384, PROT_READ) = 0
mprotect(0x55e9d85c1000, 4096, PROT_READ) = 0
mprotect(0x7f251dbd2000, 4096, PROT_READ) = 0
munmap(0x7f251dba1000, 197410)          = 0
getpid()                                = 12084
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f251dba0790) = 12085
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
brk(NULL)                               = 0x55e9d8a83000
brk(0x55e9d8aa4000)                     = 0x55e9d8aa4000
write(1, "parent (self=12084, child=12085)"..., 33) = 33
wait4(-1, NULL, 0, NULL)                = 12085
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=12085, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

#+begin_example
$ strace -f -o fork-write.log ./fork-write
parent (self=13965, child=13966)
child (self=13966)
$ cat fork-write.log
13965 execve("./fork-write", ["./fork-write"], 0x7ffe20ff4128 /* 71 vars */) = 0
13965 brk(NULL)                         = 0x56090d54d000
13965 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13965 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
13965 openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
13965 fstat(3, {st_mode=S_IFREG|0644, st_size=197410, ...}) = 0
13965 mmap(NULL, 197410, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f22aa157000
13965 close(3)                          = 0
13965 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13965 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
13965 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
13965 fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
13965 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f22aa155000
13965 mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f22a9b70000
13965 mprotect(0x7f22a9d57000, 2097152, PROT_NONE) = 0
13965 mmap(0x7f22a9f57000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f22a9f57000
13965 mmap(0x7f22a9f5d000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f22a9f5d000
13965 close(3)                          = 0
13965 arch_prctl(ARCH_SET_FS, 0x7f22aa1564c0) = 0
13965 mprotect(0x7f22a9f57000, 16384, PROT_READ) = 0
13965 mprotect(0x56090c3dc000, 4096, PROT_READ) = 0
13965 mprotect(0x7f22aa188000, 4096, PROT_READ) = 0
13965 munmap(0x7f22aa157000, 197410)    = 0
13965 getpid()                          = 13965
13965 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f22aa156790) = 13966
13965 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
13965 brk(NULL)                         = 0x56090d54d000
13965 brk(0x56090d56e000)               = 0x56090d56e000
13965 write(1, "parent (self=13965, child=13966)"..., 33) = 33
13965 wait4(-1,  <unfinished ...>
13966 getpid()                          = 13966
13966 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 1), ...}) = 0
13966 brk(NULL)                         = 0x56090d54d000
13966 brk(0x56090d56e000)               = 0x56090d56e000
13966 write(1, "child (self=13966)\n", 19) = 19
13966 exit_group(0)                     = ?
13966 +++ exited with 0 +++
13965 <... wait4 resumed> NULL, 0, NULL) = 13966
13965 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=13966, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
13965 exit_group(0)                     = ?
13965 +++ exited with 0 +++
#+end_example

* TODO Пример: фильтрация системных вызовов

#+begin_example
$ strace -o write.log ./write
write me to stdout
$ cat write.log                                                                                                                                  12:28:18
execve("./write", ["./write"], 0x7ffe46ee03a0 /* 71 vars */) = 0
brk(NULL)                               = 0x562ef09cf000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=197410, ...}) = 0
mmap(NULL, 197410, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f01ff92a000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f01ff928000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f01ff343000
mprotect(0x7f01ff52a000, 2097152, PROT_NONE) = 0
mmap(0x7f01ff72a000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f01ff72a000
mmap(0x7f01ff730000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f01ff730000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7f01ff9294c0) = 0
mprotect(0x7f01ff72a000, 16384, PROT_READ) = 0
mprotect(0x562eef0a0000, 4096, PROT_READ) = 0
mprotect(0x7f01ff95b000, 4096, PROT_READ) = 0
munmap(0x7f01ff92a000, 197410)          = 0
write(1, "write me to stdout\n\0", 20)  = 20
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

#+begin_example
$ strace -e trace=write -o write.log ./write
write me to stdout
$ cat write.log                                                                                                                                  12:31:13
write(1, "write me to stdout\n\0", 20)  = 20
+++ exited with 0 +++
#+end_example

#+begin_example
$ strace -e trace=\!mmap,access,mprotect,brk -o write.log ./write
write me to stdout
$ cat write.log
execve("./write", ["./write"], 0x7ffe896a5000 /* 75 vars */) = 0
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=197410, ...}) = 0
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7fe491d194c0) = 0
munmap(0x7fe491d1a000, 197410)          = 0
write(1, "write me to stdout\n\0", 20)  = 20
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

#+begin_example
$ strace -e trace=%file -o write.log ./write
write me to stdout
$ cat write.log
execve("./write", ["./write"], 0x7fffb7853d90 /* 75 vars */) = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
+++ exited with 0 +++
#+end_example

#+begin_example
$ strace -e trace=%memory -o write.log ./write
write me to stdout
$ cat write.log
brk(NULL)                               = 0x55fb49906000
mmap(NULL, 197410, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fd5fe669000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd5fe667000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fd5fe082000
mprotect(0x7fd5fe269000, 2097152, PROT_NONE) = 0
mmap(0x7fd5fe469000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7fd5fe469000
mmap(0x7fd5fe46f000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fd5fe46f000
mprotect(0x7fd5fe469000, 16384, PROT_READ) = 0
mprotect(0x55fb48178000, 4096, PROT_READ) = 0
mprotect(0x7fd5fe69a000, 4096, PROT_READ) = 0
munmap(0x7fd5fe669000, 197410)          = 0
+++ exited with 0 +++
#+end_example

* TODO Пример: пути к файлами вместо дескрипторов

#+begin_src c
void do_write(int out_fd)
{
    char str[] = "write me to a file\n";

    if (sizeof(str) != write(out_fd, str, sizeof(str))){
        perror("write");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    char tmp_filename_template[] = "/tmp/output_fileXXXXXX";

    int out_fd = mkstemp(tmp_filename_template);
    if (out_fd == -1) {
        perror("mkstemp");
        exit(EXIT_FAILURE);
    }

    do_write(out_fd);

    return EXIT_SUCCESS;
}
#+end_src

#+begin_example
$ strace -e trace=write -o write-tmp-file.log ./write-tmp-file
$ cat write-tmp-file.log
write(3, "write me to a file\n\0", 20)  = 20
+++ exited with 0 +++
#+end_example

#+begin_example
$ strace -y -e trace=write -o write-tmp-file.log ./write-tmp-file
$ cat write-tmp-file.log
write(3</tmp/output_fileCf5MyW>, "write me to a file\n\0", 20) = 20
+++ exited with 0 +++
#+end_example

* TODO Пример: отслеживание обращений к путям

#+begin_src c
void do_write(int out_fd)
{
    char str[] = "write me to a file\n";

    if (sizeof(str) != write(out_fd, str, sizeof(str))){
        perror("write");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    /*
     * Path will be provided by the first program argument.
     *  */
    const char *path = argv[1];

    /*
     * Open an existing file for writing in append mode.
     *  */
    int out_fd = open(path, O_APPEND | O_WRONLY);
    if (out_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    do_write(out_fd);

    return EXIT_SUCCESS;
}

#+end_src

#+begin_example
$ strace -y -o write-file.log ./write-file /tmp/test_file.log
open: No such file or directory
$ touch /tmp/test_file.log
$ strace -y -o write-file.log ./write-file /tmp/test_file.log
$ cat write-file.log
execve("./write-file", ["./write-file", "/tmp/test_file.log"], 0x7fff3df2b660 /* 64 vars */) = 0
brk(NULL)                               = 0x563127f35000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3</etc/ld.so.cache>
fstat(3</etc/ld.so.cache>, {st_mode=S_IFREG|0644, st_size=124066, ...}) = 0
mmap(NULL, 124066, PROT_READ, MAP_PRIVATE, 3</etc/ld.so.cache>, 0) = 0x7f1e7145e000
close(3</etc/ld.so.cache>)              = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3</lib/x86_64-linux-gnu/libc-2.27.so>
read(3</lib/x86_64-linux-gnu/libc-2.27.so>, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
fstat(3</lib/x86_64-linux-gnu/libc-2.27.so>, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f1e7145c000
mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3</lib/x86_64-linux-gnu/libc-2.27.so>, 0) = 0x7f1e70e65000
mprotect(0x7f1e7104c000, 2097152, PROT_NONE) = 0
mmap(0x7f1e7124c000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3</lib/x86_64-linux-gnu/libc-2.27.so>, 0x1e7000) = 0x7f1e7124c000
mmap(0x7f1e71252000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f1e71252000
close(3</lib/x86_64-linux-gnu/libc-2.27.so>) = 0
arch_prctl(ARCH_SET_FS, 0x7f1e7145d4c0) = 0
mprotect(0x7f1e7124c000, 16384, PROT_READ) = 0
mprotect(0x56312604f000, 4096, PROT_READ) = 0
mprotect(0x7f1e7147d000, 4096, PROT_READ) = 0
munmap(0x7f1e7145e000, 124066)          = 0
openat(AT_FDCWD, "/tmp/test_file.log", O_WRONLY|O_APPEND) = 3</tmp/test_file.log>
write(3</tmp/test_file.log>, "write me to a file\n\0", 20) = 20
exit_group(0)                           = ?
+++ exited with 0 +++
#+end_example

#+begin_example
$ strace -y -P/tmp/test_file.log -o write-file.log ./write-file /tmp/test_file.log
$ cat write-file.log
openat(AT_FDCWD, "/tmp/test_file.log", O_WRONLY|O_APPEND) = 3</tmp/test_file.log>
write(3</tmp/test_file.log>, "write me to a file\n\0", 20) = 20
+++ exited with 0 +++
#+end_example

* TODO Пример: многопоточные программы

#+begin_src c
void *thread(void *arg)
{
    (void) arg;

    printf("Secondary thread: working\n");
    sleep(1);
    printf("Secondary thread: done\n");

    return NULL;
}

int main(int argc, char *argv[])
{
    printf("Initial thread: launching a thread\n");

    pthread_t thr;
    if (0 != pthread_create(&thr, NULL, thread, NULL)) {
        fprintf(stderr, "Initial thread: failed to create a thread");
        exit(EXIT_FAILURE);
    }

    printf("Initial thread: joining a thread\n");
    if (0 != pthread_join(thr, NULL)) {
        fprintf(stderr, "Initial thread: failed to join a thread");
        exit(EXIT_FAILURE);
    };

    printf("Initial thread: done");

    exit(EXIT_SUCCESS);
}
#+end_src

#+begin_example
$ gcc examples/thread-write.c -pthread -o thread-write
$ strace -f -othread-write.log ./thread-write
$ wc -l thread-write.log
60 thread-write.log
$ strace -f -e trace="%process,%desc" -othread-write.log ./thread-write
$ wc -l thread-write.log
34 thread-write.log
$ cat thread-write.log
30418 execve("./thread-write", ["./thread-write"], 0x7fff42e01b80 /* 64 vars */) = 0
30418 openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
30418 fstat(3, {st_mode=S_IFREG|0644, st_size=124066, ...}) = 0
30418 mmap(NULL, 124066, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fa91238c000
30418 close(3)                          = 0
30418 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3
30418 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0000b\0\0\0\0\0\0"..., 832) = 832
30418 fstat(3, {st_mode=S_IFREG|0755, st_size=144976, ...}) = 0
30418 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa91238a000
30418 mmap(NULL, 2221184, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa911f65000
30418 mmap(0x7fa91217e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19000) = 0x7fa91217e000
30418 mmap(0x7fa912180000, 13440, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fa912180000
30418 close(3)                          = 0
30418 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
30418 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\260\34\2\0\0\0\0\0"..., 832) = 832
30418 fstat(3, {st_mode=S_IFREG|0755, st_size=2030544, ...}) = 0
30418 mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa911b74000
30418 mmap(0x7fa911f5b000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7fa911f5b000
30418 mmap(0x7fa911f61000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fa911f61000
30418 close(3)                          = 0
30418 mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa912387000
30418 arch_prctl(ARCH_SET_FS, 0x7fa912387740) = 0
30418 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
30418 write(1, "Initial thread: launching a thre"..., 35) = 35
30418 mmap(NULL, 8392704, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7fa911373000
30418 clone(child_stack=0x7fa911b72fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fa911b739d0, tls=0x7fa911b73700, child_tidptr=0x7fa911b739d0) = 30419
30418 write(1, "Initial thread: joining a thread"..., 33) = 33
30419 write(1, "Secondary thread: working\n", 26) = 26
30419 write(1, "Secondary thread: done\n", 23) = 23
30419 exit(0)                           = ?
30419 +++ exited with 0 +++
30418 write(1, "Initial thread: done", 20) = 20
30418 exit_group(0)                     = ?
30418 +++ exited with 0 +++
#+end_example

* TODO Пример: стек процесса в момент системного вызова

#+begin_src c
void do_write(void)
{
    char str[] = "write me to stdout\n";
    if (sizeof(str) != write(STDOUT_FILENO, str, sizeof(str))){
        perror("write");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    do_write();
    return EXIT_SUCCESS;
}
#+end_src

#+begin_example
$ gcc examples/write-simple.c -o write-simple
$ strace -k -e trace="write" -owrite-simple.log ./write-simple
write me to stdout
$ cat write-simple.log
write(1, "write me to stdout\n\0", 20)  = 20
 > /lib/x86_64-linux-gnu/libc-2.27.so(__write+0x14) [0x110154]
 > /home/vkazanov/projects-my/strace-post/write-simple(do_write+0x50) [0x78a]
 > /home/vkazanov/projects-my/strace-post/write-simple(main+0x14) [0x7d1]
 > /lib/x86_64-linux-gnu/libc-2.27.so(__libc_start_main+0xe7) [0x21b97]
 > /home/vkazanov/projects-my/strace-post/write-simple(_start+0x2a) [0x65a]
+++ exited with 0 +++
#+end_example

* TODO Пример: инъекция ошибок

#+begin_src c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void do_write(const char *str, ssize_t len)
{
    if (len != write(STDOUT_FILENO, str, (size_t)len)){
        perror("write");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    (void) argc; (void) argv;

    char str1[] = "write me 1\n";
    do_write(str1, sizeof(str1));

    char str2[] = "write me 2\n";
    do_write(str2, sizeof(str2));

    return EXIT_SUCCESS;
}
#+end_src

#+begin_example
$ gcc examples/write-twice.c -o write-twice
$ ./write-twice
write me 1
write me 2
$ strace -e trace=write -owrite-twice.log ./write-twice
write me 1
write me 2
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = 12
write(1, "write me 2\n\0", 12)          = 12
+++ exited with 0 +++
#+end_example

#+begin_example
$ strace -e trace=write -e inject=write:error=EBADF -owrite-twice.log ./write-twice
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = -1 EBADF (Bad file descriptor) (INJECTED)
write(3, "write: Bad file descriptor\n", 27) = -1 EBADF (Bad file descriptor) (INJECTED)
+++ exited with 1 +++
$ strace -e trace=write -e inject=write:error=EBADF:when=1 -owrite-twice.log ./write-twice
write: Bad file descriptor
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = -1 EBADF (Bad file descriptor) (INJECTED)
write(3, "write: Bad file descriptor\n", 27) = 27
+++ exited with 1 +++
$ strace -e trace=write -e inject=write:error=EBADF:when=2 -owrite-twice.log ./write-twice
write me 1
write: Bad file descriptor
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = 12
write(1, "write me 2\n\0", 12)          = -1 EBADF (Bad file descriptor) (INJECTED)
write(3, "write: Bad file descriptor\n", 27) = 27
+++ exited with 1 +++
#+end_example

#+begin_example
$ strace -e trace=write -e fault=write:when=1 -owrite-twice.log ./write-twice
$ cat write-twice.log
write(1, "write me 1\n\0", 12)          = -1 ENOSYS (Function not implemented) (INJECTED)
write(3, "write: Function not implemented\n", 32) = 32
+++ exited with 1 +++
#+end_example
